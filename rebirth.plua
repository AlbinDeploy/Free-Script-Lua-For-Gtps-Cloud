import makeWASocket, {  DisconnectReason,  fetchLatestBaileysVersion,  useMultiFileAuthState,  jidDecode,  downloadContentFromMessage,  proto,} from "@whiskeysockets/baileys";import P from "pino";import { Sticker, StickerTypes } from "wa-sticker-formatter";import { promises as fs } from "fs";import path from "path";import { createCanvas, loadImage } from "@napi-rs/canvas";const BOT_NAME = "Kintaro Bot";const OWNER_NUMBER_RAW = "089530276332";const OWNER_NAME = "Owner Kintaro";const OWNER_GITHUB = "https://github.com/";const OPENROUTER_KEYS: string[] = ["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", "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"];const OPENROUTER_MODEL = "openai/gpt-4o-mini";const OPENROUTER_ENDPOINT = "https://openrouter.ai/api/v1/chat/completions";const startTimeMs = Date.now();const recentWelcomes = new Map<string, number>();const antiLinkEnabledByGroup = new Map<string, boolean>();const groupMetaCache = new Map<string, { ts: number; meta: any }>();const GROUP_META_TTL_MS = 30_000;type Participant = string | { id?: string; phoneNumber?: string; admin?: string | null };function shouldSendWelcome(key: string, ttlMs = 10000): boolean {  const now = Date.now();  const last = recentWelcomes.get(key);  if (last && now - last < ttlMs) return false;  recentWelcomes.set(key, now);  setTimeout(() => recentWelcomes.delete(key), ttlMs);  return true;}function participantToJid(p: Participant): string {  if (typeof p === "string") return p;  if (p.phoneNumber && p.phoneNumber.includes("@")) return p.phoneNumber;  if (p.id) return p.id;  return "";}function getMentionNumber(jid: string): string {  if (jid.includes("@s.whatsapp.net")) return jid.split("@")[0];  const decoded = jidDecode(jid);  if (decoded?.user) return decoded.user;  return jid.split("@")[0];}function normalizePhoneNumber(input: string): string {  return input.replace(/\D/g, "");}function toIndonesiaE164Digits(input: string): string {  let n = normalizePhoneNumber(input);  if (n.startsWith("0")) n = "62" + n.slice(1);  if (n.startsWith("62")) return n;  return n;}function toUserJidFromPhone(input: string): string {  const digits = toIndonesiaE164Digits(input);  return digits + "@s.whatsapp.net";}function formatDuration(secondsTotal: number): string {  const s = Math.floor(secondsTotal);  const d = Math.floor(s / 86400);  const h = Math.floor((s % 86400) / 3600);  const m = Math.floor((s % 3600) / 60);  const sec = s % 60;  const parts: string[] = [];  if (d) parts.push(`${d}d`);  if (h) parts.push(`${h}h`);  if (m) parts.push(`${m}m`);  parts.push(`${sec}s`);  return parts.join(" ");}const TAG_NEW_MEMBER = true;const WELCOME_TEXT = `*Welcome To AseanPS**Link Apk AseanPS*: https://www.mediafire.com/file/w7s494i6gk7rk1x/Growtopia_5.38_apks-1%25282%2529.apk/file*Host PowerTunnel*: https://gtpshost.com/raw/BOLDPS*Host Surge 5*: https://gtpshost.com/ios/BOLDPS*Host Windows*:157.245.206.78 www.growtopia1.com157.245.206.78 www.growtopia2.com*Link Grup*: https://chat.whatsapp.com/BNhtbjXm71XAGK6vlcutqQ?mode=ac_t*Tutorial Login**For Android PowerTunnel*1. First, download Powertunnel APP from here. https://github.com/krlvm/PowerTunnel-Android/releases/download/v2.6.3/PowerTunnel.apk2. Then click on the "Powertunnel" button.3. It will copy the Powertunnel host link.4. Open the Powertunnel app, click the three-line icon, then click the host settings icon.5. Paste the copied Powertunnel host URL. Change the host update period from 12 hours to "on start".6. Now you can log in to your GTPS!*For IOS Surge 5*1. Download an app called "Surge 5" from the App Store.2. Press "OK".3. Click on "Default.conf".4. Click on "IMPORT"  "Download Profile from URL".5. Paste the URL you copied when clicking the iOS host button above, then click "OK" and "Done".6. Press "SETUP", agree to the policy, then click "OK" and "Allow" for VPN Configuration.7. Done! Now open Growtopia and connect.*For Windows*1. Press  Win+R (Windows Key + R) to open the "Run" window.2. Type C:\\Windows\\System32\\drivers\\etc in the textbox.3. Find the file named hosts.4. Right-click on the "hosts" file and edit it with Notepad/text editor.5. Download the host file, open it, copy and add the IP above.6. Save, then log in to your Growtopia.`;function isAntiLinkOn(groupJid: string): boolean {  return antiLinkEnabledByGroup.get(groupJid) === true;}function setAntiLink(groupJid: string, on: boolean): void {  antiLinkEnabledByGroup.set(groupJid, on);}const LINK_REGEX =  /(?:https?:\/\/\S+)|(?:www\.\S+)|(?:\b(?:[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?\.)+(?:[a-z]{2,})(?:\/\S*)?\b)|(?:\b\d{1,3}(?:\.\d{1,3}){3}(?::\d{2,5})?\b)|(?:\b[a-z0-9-]{2,}\s*(?:\[\.\]|\(\.\)|\.)\s*[a-z]{2,}\b)/gi;const WHITELIST_DOMAINS: string[] = [];function extractLinks(text: string): string[] {  if (!text) return [];  const matches = text.match(LINK_REGEX) ?? [];  return matches.map((m) => m.trim());}function isWhitelisted(textWithLink: string): boolean {  if (WHITELIST_DOMAINS.length === 0) return false;  const lower = textWithLink.toLowerCase().replace(/\s+/g, "");  return WHITELIST_DOMAINS.some((d) => lower.includes(d.toLowerCase()));}function getMessageText(msg: any): string {  return (    msg?.message?.conversation ||    msg?.message?.extendedTextMessage?.text ||    msg?.message?.imageMessage?.caption ||    msg?.message?.videoMessage?.caption ||    msg?.message?.documentMessage?.caption ||    ""  );}async function getGroupMeta(sock: any, groupJid: string) {  const cached = groupMetaCache.get(groupJid);  const now = Date.now();  if (cached && now - cached.ts < GROUP_META_TTL_MS) return cached.meta;  const meta = await sock.groupMetadata(groupJid);  groupMetaCache.set(groupJid, { ts: now, meta });  return meta;}function isSenderAdmin(meta: any, senderJid: string): boolean {  return meta.participants.some(    (p: any) => p.id === senderJid && (p.admin === "admin" || p.admin === "superadmin")  );}async function streamToBuffer(stream: AsyncIterable<Buffer>): Promise<Buffer> {  const chunks: Buffer[] = [];  for await (const chunk of stream) chunks.push(chunk);  return Buffer.concat(chunks);}async function makeStickerFromImageBuffer(imageBuf: Buffer): Promise<Buffer> {  const sticker = new Sticker(imageBuf, {    pack: "Kintaro Pack",    author: BOT_NAME,    type: StickerTypes.FULL,    quality: 70,  });  return await sticker.toBuffer();}async function makeStickerFromVideoBuffer(videoBuf: Buffer): Promise<Buffer> {  const sticker = new Sticker(videoBuf, {    pack: "Kintaro Pack",    author: BOT_NAME,    type: StickerTypes.FULL,    quality: 70,  } as any);  return await sticker.toBuffer();}function getQuotedImageMessage(msg: proto.IWebMessageInfo): proto.IImageMessage | null {  const ext = msg.message?.extendedTextMessage;  const quoted = ext?.contextInfo?.quotedMessage;  if (!quoted) return null;  if (quoted.imageMessage) return quoted.imageMessage;  return null;}function getQuotedVideoMessage(msg: proto.IWebMessageInfo): proto.IVideoMessage | null {  const ext = msg.message?.extendedTextMessage;  const quoted = ext?.contextInfo?.quotedMessage;  if (!quoted) return null;  if (quoted.videoMessage) return quoted.videoMessage;  return null;}function getQuotedStickerMessage(msg: proto.IWebMessageInfo): proto.IStickerMessage | null {  const ext = msg.message?.extendedTextMessage;  const quoted = ext?.contextInfo?.quotedMessage;  if (!quoted) return null;  if (quoted.stickerMessage) return quoted.stickerMessage;  return null;}type ResponseDB = { groups: Record<string, Record<string, string>> };const RESP_FILE = path.join(process.cwd(), "responses.json");let responseDB: ResponseDB = { groups: {} };async function loadResponses(): Promise<void> {  try {    const raw = await fs.readFile(RESP_FILE, "utf8");    const parsed = JSON.parse(raw) as ResponseDB;    if (parsed && typeof parsed === "object" && parsed.groups) responseDB = parsed;  } catch {    responseDB = { groups: {} };  }}async function saveResponses(): Promise<void> {  await fs.writeFile(RESP_FILE, JSON.stringify(responseDB, null, 2), "utf8");}function getGroupResponses(groupJid: string): Record<string, string> {  if (!responseDB.groups[groupJid]) responseDB.groups[groupJid] = {};  return responseDB.groups[groupJid];}type BotSettings = {  groups: Record<    string,    {      welcomeOn?: boolean;      welcomeText?: string;      muted?: boolean;      whitelistDomains?: string[];      filters?: Record<string, string>;    }  >;  afk?: Record<string, { since: number; reason: string }>;};const SETTINGS_FILE = path.join(process.cwd(), "settings.json");let settings: BotSettings = { groups: {}, afk: {} };function getGroupSettings(groupJid: string) {  if (!settings.groups[groupJid]) settings.groups[groupJid] = {};  const g = settings.groups[groupJid];  if (!g.whitelistDomains) g.whitelistDomains = [];  if (!g.filters) g.filters = {};  if (typeof g.welcomeOn !== "boolean") g.welcomeOn = true;  if (typeof g.welcomeText !== "string") g.welcomeText = WELCOME_TEXT;  if (typeof g.muted !== "boolean") g.muted = false;  return g;}async function loadSettings(): Promise<void> {  try {    const raw = await fs.readFile(SETTINGS_FILE, "utf8");    const parsed = JSON.parse(raw) as BotSettings;    if (parsed && typeof parsed === "object" && parsed.groups) settings = parsed;    if (!settings.afk) settings.afk = {};    if (!settings.groups) settings.groups = {};  } catch {    settings = { groups: {}, afk: {} };  }}async function saveSettings(): Promise<void> {  await fs.writeFile(SETTINGS_FILE, JSON.stringify(settings, null, 2), "utf8");}function buildMenu(isGroup: boolean, antilinkOn?: boolean): string {  const statusLine = isGroup ? `• AntiLink: ${antilinkOn ? "ON" : "OFF"}` : "";  return `*${BOT_NAME}* *Commands*• .menu• .ping• .uptime• .ai <teks>• .brat <teks>• .quote <teks>• .tts <teks>• .owner• .admin• .s / .sticker• .toimg• .afk <alasan>*Group (Admin)*• .tagall <pesan>• .setwelcome <teks>• .welcome on/off• .setppgc• .kick @tag / reply• .add 628xxxx• .mute on/off• .antilink on/off• .antilink whitelist add <domain>• .antilink whitelist del <domain>• .antilink whitelist list• .filter add kata|jawaban• .filter del kata• .filter list• .hidetag <pesan>• .addrespon kata|jawaban• .delrespon kata• .listrespon*Status*• Chat: ${isGroup ? "Group" : "Private"}${statusLine}`.trim();}function normalizeKeyList(keys: string[]): string[] {  return keys.map((k) => k.trim()).filter((k) => k.length > 0 && !k.includes("PASTE_KEY"));}function getKeysFromEnvOrArray(): string[] {  const fromEnv = (process.env.OPENROUTER_KEYS ?? "").trim();  if (fromEnv) {    return fromEnv      .split(",")      .map((s) => s.trim())      .filter((s) => s.length > 0);  }  return normalizeKeyList(OPENROUTER_KEYS);}let openrouterKeyIndex = 0;async function callOpenRouter(prompt: string): Promise<string> {  const keys = getKeysFromEnvOrArray();  if (keys.length === 0) return "OpenRouter key belum diset.";  const start = openrouterKeyIndex;  for (let i = 0; i < keys.length; i++) {    const idx = (start + i) % keys.length;    const key = keys[idx];    try {      const res = await fetch(OPENROUTER_ENDPOINT, {        method: "POST",        headers: {          Authorization: `Bearer ${key}`,          "Content-Type": "application/json",          "HTTP-Referer": "https://localhost",          "X-Title": BOT_NAME,        },        body: JSON.stringify({          model: OPENROUTER_MODEL,          messages: [{ role: "user", content: prompt }],        }),      });      if (!res.ok) {        const t = await res.text().catch(() => "");        if ([401, 402, 403, 429, 500, 502, 503].includes(res.status)) continue;        return `OpenRouter error ${res.status}: ${t.slice(0, 300)}`;      }      const data: any = await res.json();      const out = data?.choices?.[0]?.message?.content ?? data?.choices?.[0]?.text ?? "";      if (typeof out === "string" && out.trim().length > 0) {        openrouterKeyIndex = idx + 1;        return out.trim();      }      continue;    } catch {      continue;    }  }  return "OpenRouter sedang error/rate limit. Coba lagi nanti.";}type SplitResult = { left: string; right: string };function sanitizeBratText(s: string): string {  return (s || "")    .replace(/\s+/g, " ")    .replace(/[^\S\r\n]+/g, " ")    .trim()    .slice(0, 450);}function tokenizeWords(s: string): string[] {  return sanitizeBratText(s).split(" ").filter(Boolean);}function setBratFont(ctx: any, size: number) {  ctx.font = `500 ${size}px "Arial Narrow", Arial, sans-serif`;}function wrapWordsToLines(ctx: any, words: string[], width: number): string[] {  const lines: string[] = [];  let line: string[] = [];  for (const w of words) {    const test = line.length ? [...line, w].join(" ") : w;    if (ctx.measureText(test).width <= width) {      line.push(w);    } else {      if (line.length) lines.push(line.join(" "));      line = [w];    }  }  if (line.length) lines.push(line.join(" "));  return lines;}function splitHeuristicToColumns(ctx: any, words: string[], colWidth: number): SplitResult {  if (words.length <= 1) return { left: words.join(" "), right: "" };  let bestIdx = Math.max(1, Math.floor(words.length / 2));  let bestScore = Number.POSITIVE_INFINITY;  for (let i = 1; i < words.length; i++) {    const leftWords = words.slice(0, i);    const rightWords = words.slice(i);    const leftLines = wrapWordsToLines(ctx, leftWords, colWidth);    const rightLines = wrapWordsToLines(ctx, rightWords, colWidth);    const lh = leftLines.length;    const rh = rightLines.length;    const maxH = Math.max(lh, rh);    const diff = Math.abs(lh - rh);    const score = maxH * 10 + diff * 3 + Math.abs(i - words.length / 2) * 0.02;    if (score < bestScore) {      bestScore = score;      bestIdx = i;    }  }  return { left: words.slice(0, bestIdx).join(" "), right: words.slice(bestIdx).join(" ") };}async function splitTextAI(text: string): Promise<SplitResult | null> {  const keys = getKeysFromEnvOrArray();  if (keys.length === 0) return null;  const prompt = `Split the text into two columns (left and right) like a two-column justified layout. Keep word order. Make both columns similar visual length. Output ONLY valid JSON: {"left":"...","right":"..."}. Text:\n${text}`;  const out = await callOpenRouter(prompt);  const raw = out.trim();  const first = raw.indexOf("{");  const last = raw.lastIndexOf("}");  if (first === -1 || last === -1 || last <= first) return null;  const slice = raw.slice(first, last + 1);  try {    const obj = JSON.parse(slice) as any;    if (typeof obj?.left === "string" && typeof obj?.right === "string") {      return { left: sanitizeBratText(obj.left), right: sanitizeBratText(obj.right) };    }    return null;  } catch {    return null;  }}function drawJustifiedLines(ctx: any, lines: string[], x: number, y: number, width: number, lineH: number) {  for (let i = 0; i < lines.length; i++) {    const line = lines[i];    const words = line.split(" ").filter(Boolean);    const isLast = i === lines.length - 1;    if (words.length <= 1 || isLast) {      ctx.fillText(line, x, y + i * lineH);      continue;    }    const totalTextWidth = ctx.measureText(line).width;    const gaps = words.length - 1;    const extra = Math.max(0, width - totalTextWidth);    const extraPerGap = extra / gaps;    let cursor = x;    for (let w = 0; w < words.length; w++) {      const word = words[w];      ctx.fillText(word, cursor, y + i * lineH);      const wordW = ctx.measureText(word).width;      cursor += wordW;      if (w < words.length - 1) {        const spaceW = ctx.measureText(" ").width;        cursor += spaceW + extraPerGap;      }    }  }}async function makeBratWhiteTwoColumnImage(textInput: string): Promise<Buffer> {  const W = 900;  const H = 900;  const pad = 70;  const gap = 70;  const colW = Math.floor((W - pad * 2 - gap) / 2);  const top = 120;  const bottom = 90;  const maxHeight = H - top - bottom;  const canvas = createCanvas(W, H);  const ctx = canvas.getContext("2d");  ctx.fillStyle = "#FFFFFF";  ctx.fillRect(0, 0, W, H);  ctx.fillStyle = "#000000";  ctx.textBaseline = "top";  ctx.textAlign = "left";  ctx.shadowColor = "rgba(0,0,0,0.35)";  ctx.shadowBlur = 2;  const full = sanitizeBratText(textInput);  if (!full) return canvas.toBuffer("image/png");  let chosen: SplitResult | null = await splitTextAI(full);  let sizeLo = 24;  let sizeHi = 120;  let best: { size: number; leftLines: string[]; rightLines: string[]; split: SplitResult } | null = null;  while (sizeLo <= sizeHi) {    const mid = Math.floor((sizeLo + sizeHi) / 2);    setBratFont(ctx, mid);    const split = chosen ?? splitHeuristicToColumns(ctx, tokenizeWords(full), colW);    const leftWords = tokenizeWords(split.left);    const rightWords = tokenizeWords(split.right);    const leftLines = wrapWordsToLines(ctx, leftWords, colW);    const rightLines = wrapWordsToLines(ctx, rightWords, colW);    const lineH = Math.floor(mid * 1.12);    const leftH = leftLines.length * lineH;    const rightH = rightLines.length * lineH;    const needH = Math.max(leftH, rightH);    if (needH <= maxHeight) {      best = { size: mid, leftLines, rightLines, split };      sizeLo = mid + 1;    } else {      sizeHi = mid - 1;    }  }  if (!best) {    const fallbackSize = 24;    setBratFont(ctx, fallbackSize);    const split = chosen ?? splitHeuristicToColumns(ctx, tokenizeWords(full), colW);    const leftLines = wrapWordsToLines(ctx, tokenizeWords(split.left), colW);    const rightLines = wrapWordsToLines(ctx, tokenizeWords(split.right), colW);    best = { size: fallbackSize, leftLines, rightLines, split };  }  setBratFont(ctx, best.size);  const lineH = Math.floor(best.size * 1.12);  const leftX = pad;  const rightX = pad + colW + gap;  const y = top;  drawJustifiedLines(ctx, best.leftLines, leftX, y, colW, lineH);  drawJustifiedLines(ctx, best.rightLines, rightX, y, colW, lineH);  ctx.shadowBlur = 0;  return canvas.toBuffer("image/png");}function wrapTextForQuote(ctx: any, text: string, maxWidth: number): string[] {  const words = (text || "").trim().split(/\s+/).filter(Boolean);  const lines: string[] = [];  let line: string[] = [];  for (const w of words) {    const test = line.length ? [...line, w].join(" ") : w;    if (ctx.measureText(test).width <= maxWidth) {      line.push(w);    } else {      if (line.length) lines.push(line.join(" "));      line = [w];    }  }  if (line.length) lines.push(line.join(" "));  return lines;}async function makeQuoteImage(textInput: string): Promise<Buffer> {  const W = 1000;  const H = 600;  const pad = 80;  const canvas = createCanvas(W, H);  const ctx = canvas.getContext("2d");  ctx.fillStyle = "#111111";  ctx.fillRect(0, 0, W, H);  ctx.fillStyle = "#FFFFFF";  ctx.textBaseline = "top";  ctx.textAlign = "left";  const text = (textInput || "").trim().slice(0, 600);  if (!text) return canvas.toBuffer("image/png");  let sizeLo = 22;  let sizeHi = 64;  let bestSize = 28;  let bestLines: string[] = [text];  while (sizeLo <= sizeHi) {    const mid = Math.floor((sizeLo + sizeHi) / 2);    ctx.font = `700 ${mid}px Arial, sans-serif`;    const lines = wrapTextForQuote(ctx, text, W - pad * 2);    const lineH = Math.floor(mid * 1.35);    const totalH = lines.length * lineH;    if (totalH <= H - pad * 2) {      bestSize = mid;      bestLines = lines;      sizeLo = mid + 1;    } else {      sizeHi = mid - 1;    }  }  ctx.font = `700 ${bestSize}px Arial, sans-serif`;  const lineH = Math.floor(bestSize * 1.35);  const totalH = bestLines.length * lineH;  const startY = Math.floor((H - totalH) / 2);  ctx.globalAlpha = 0.15;  ctx.font = `900 ${Math.floor(bestSize * 3)}px Arial, sans-serif`;  ctx.fillText("“", pad, pad - 10);  ctx.fillText("”", W - pad - Math.floor(bestSize * 2), H - pad - Math.floor(bestSize * 2));  ctx.globalAlpha = 1;  ctx.font = `700 ${bestSize}px Arial, sans-serif`;  for (let i = 0; i < bestLines.length; i++) {    ctx.fillText(bestLines[i], pad, startY + i * lineH);  }  ctx.globalAlpha = 0.7;  ctx.font = `500 22px Arial, sans-serif`;  ctx.fillText(`— ${BOT_NAME}`, pad, H - pad + 10);  ctx.globalAlpha = 1;  return canvas.toBuffer("image/png");}async function textToSpeechMP3(textInput: string, lang = "id"): Promise<Buffer> {  const q = encodeURIComponent((textInput || "").trim().slice(0, 200));  const url = `https://translate.google.com/translate_tts?ie=UTF-8&client=tw-ob&tl=${encodeURIComponent(    lang  )}&q=${q}`;  const res = await fetch(url, {    headers: {      "User-Agent":        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120 Safari/537.36",    },  });  if (!res.ok) {    const t = await res.text().catch(() => "");    throw new Error(`TTS error ${res.status}: ${t.slice(0, 200)}`);  }  const arr = await res.arrayBuffer();  return Buffer.from(arr);}async function stickerWebpToPng(webpBuf: Buffer): Promise<Buffer> {  const img = await loadImage(webpBuf);  const canvas = createCanvas(img.width, img.height);  const ctx = canvas.getContext("2d");  ctx.drawImage(img as any, 0, 0);  return canvas.toBuffer("image/png");}function getMentionedJids(msg: proto.IWebMessageInfo): string[] {  const ext = msg.message?.extendedTextMessage;  const jids = (ext?.contextInfo?.mentionedJid as string[]) || [];  return Array.isArray(jids) ? jids : [];}function isOwnerJid(jid: string): boolean {  const ownerJid = toUserJidFromPhone(OWNER_NUMBER_RAW);  return jid === ownerJid;}function isBotAdminInGroup(meta: any, botJid: string): boolean {  return meta.participants.some(    (p: any) => p.id === botJid && (p.admin === "admin" || p.admin === "superadmin")  );}function normalizeDomain(input: string): string {  let s = (input || "").trim().toLowerCase();  s = s.replace(/^https?:\/\//, "").replace(/^www\./, "");  s = s.split("/")[0].trim();  return s;}function isWhitelistedForGroup(groupJid: string, textWithLink: string): boolean {  const g = getGroupSettings(groupJid);  const local = (g.whitelistDomains || []).map((d) => d.toLowerCase());  const global = WHITELIST_DOMAINS.map((d) => d.toLowerCase());  const lower = textWithLink.toLowerCase().replace(/\s+/g, "");  return [...local, ...global].some((d) => d && lower.includes(d));}async function sendOwnerContact(sock: any, to: string) {  const ownerDigits = toIndonesiaE164Digits(OWNER_NUMBER_RAW);  const vcard = [    "BEGIN:VCARD",    "VERSION:3.0",    `FN:${OWNER_NAME}`,    `ORG:${BOT_NAME}`,    `TEL;type=CELL;type=VOICE;waid=${ownerDigits}:${ownerDigits}`,    `URL:${OWNER_GITHUB}`,    "END:VCARD",  ].join("\n");  await sock.sendMessage(to, {    contacts: {      displayName: OWNER_NAME,      contacts: [{ vcard }],    },  });}async function start(): Promise<void> {  await loadResponses();  await loadSettings();  const botNumberRaw = process.env.BOT_NUMBER ?? "";  const botNumber = normalizePhoneNumber(botNumberRaw);  if (!botNumber) {    console.log("BOT_NUMBER kosong. Contoh: set BOT_NUMBER=628xxxx && npm run start");    process.exit(1);  }  const { state, saveCreds } = await useMultiFileAuthState("auth");  const { version } = await fetchLatestBaileysVersion();  const sock = makeWASocket({    version,    auth: state,    logger: P({ level: "info" }),    printQRInTerminal: false,  });  sock.ev.on("creds.update", saveCreds);  if (!sock.authState.creds.registered) {    setTimeout(async () => {      try {        const code = await sock.requestPairingCode(botNumber);        console.log("Nomer bot :", botNumber);        console.log("Kode pairing:", code);      } catch (err) {        console.error(err);      }    }, 3000);  }  sock.ev.on("connection.update", (u) => {    const { connection, lastDisconnect } = u;    if (connection === "close") {      const statusCode = (lastDisconnect?.error as any)?.output?.statusCode as number | undefined;      const shouldReconnect = statusCode !== DisconnectReason.loggedOut;      if (shouldReconnect) start().catch(console.error);    }  });  sock.ev.on("group-participants.update", async (update) => {    try {      if (update.action !== "add") return;      const groupJid = update.id;      const g = getGroupSettings(groupJid);      if (!g.welcomeOn) return;      const jids = (update.participants as any[])        .map((p) => participantToJid(p))        .filter((x) => x.length > 0);      for (const jid of jids) {        const dedupeKey = `${groupJid}:${jid}`;        if (!shouldSendWelcome(dedupeKey)) return;      }      const textWelcome = typeof g.welcomeText === "string" ? g.welcomeText : WELCOME_TEXT;      if (TAG_NEW_MEMBER) {        const mentionText = jids.map((jid) => `@${getMentionNumber(jid)}`).join(" ");        await sock.sendMessage(groupJid, { text: `${mentionText}\n\n${textWelcome}`, mentions: jids });      } else {        await sock.sendMessage(groupJid, { text: textWelcome });      }    } catch {}  });  sock.ev.on("messages.upsert", async ({ messages }) => {    try {      const msg = messages[0];      if (!msg?.message) return;      if (msg.key.fromMe) return;      const remoteJid = msg.key.remoteJid;      if (!remoteJid) return;      const senderJid = msg.key.participant || msg.key.remoteJid || "";      const textRaw = getMessageText(msg);      const text = (textRaw ?? "").trim();      const isGroup = remoteJid.endsWith("@g.us");      const mentioned = getMentionedJids(msg);      if (settings.afk && settings.afk[senderJid] && text.length > 0) {        delete settings.afk[senderJid];        await saveSettings();        await sock.sendMessage(remoteJid, { text: ` @${getMentionNumber(senderJid)} AFK off`, mentions: [senderJid] });      }      if (mentioned.length > 0 && settings.afk) {        const afkHits = mentioned          .map((j) => ({ jid: j, data: settings.afk![j] }))          .filter((x) => x.data && typeof x.data.reason === "string");        if (afkHits.length > 0) {          const lines = afkHits.map(            (x) =>              `@${getMentionNumber(x.jid)} AFK: ${x.data!.reason} (${formatDuration((Date.now() - x.data!.since) / 1000)})`          );          await sock.sendMessage(remoteJid, { text: lines.join("\n"), mentions: afkHits.map((x) => x.jid) });        }      }      if (text === ".owner") {        await sendOwnerContact(sock, remoteJid);        return;      }      if (text === ".ping") {        const tsSec = Number(msg.messageTimestamp ?? 0);        const nowMs = Date.now();        const msgMs = tsSec ? tsSec * 1000 : nowMs;        const diffMs = Math.max(0, nowMs - msgMs);        await sock.sendMessage(remoteJid, { text: ` Pong! ~${diffMs}ms` });        return;      }      if (text === ".uptime") {        await sock.sendMessage(remoteJid, { text: ` Uptime: ${formatDuration(process.uptime())}` });        return;      }      if (text === ".menu") {        await sock.sendMessage(remoteJid, {          text: buildMenu(isGroup, isGroup ? isAntiLinkOn(remoteJid) : undefined),        });        return;      }      if (text.startsWith(".ai")) {        const prompt = text.replace(/^\.ai\b/i, "").trim();        if (!prompt) {          await sock.sendMessage(remoteJid, { text: "Contoh: .ai jelasin cara bikin stiker" });          return;        }        const out = await callOpenRouter(prompt);        await sock.sendMessage(remoteJid, { text: out.slice(0, 4000) });        return;      }      if (text.startsWith(".brat")) {        const payload = text.replace(/^\.brat\b/i, "").trim();        if (!payload) {          await sock.sendMessage(remoteJid, {            text: "Contoh: .brat brat and it's the same but there's three more songs so it's not",          });          return;        }        try {          const img = await makeBratWhiteTwoColumnImage(payload);          await sock.sendMessage(remoteJid, { image: img });        } catch {          await sock.sendMessage(remoteJid, { text: "Gagal bikin gambar brat." });        }        return;      }      if (text.startsWith(".quote")) {        const payload = text.replace(/^\.quote\b/i, "").trim();        if (!payload) {          await sock.sendMessage(remoteJid, { text: "Contoh: .quote jangan menyerah" });          return;        }        try {          const img = await makeQuoteImage(payload);          await sock.sendMessage(remoteJid, { image: img });        } catch {          await sock.sendMessage(remoteJid, { text: "Gagal bikin quote." });        }        return;      }      if (text.startsWith(".tts")) {        const payload = text.replace(/^\.tts\b/i, "").trim();        if (!payload) {          await sock.sendMessage(remoteJid, { text: "Contoh: .tts halo semuanya" });          return;        }        try {          const mp3 = await textToSpeechMP3(payload, "id");          await sock.sendMessage(remoteJid, { audio: mp3, mimetype: "audio/mpeg", ptt: true });        } catch {          await sock.sendMessage(remoteJid, { text: "Gagal TTS." });        }        return;      }      if (text.startsWith(".afk")) {        const payload = text.replace(/^\.afk\b/i, "").trim();        const reason = payload.length ? payload.slice(0, 120) : "AFK";        if (!settings.afk) settings.afk = {};        settings.afk[senderJid] = { since: Date.now(), reason };        await saveSettings();        await sock.sendMessage(remoteJid, { text: ` @${getMentionNumber(senderJid)} AFK: ${reason}`, mentions: [senderJid] });        return;      }      const hasImageWithStickerCaption =        !!msg.message.imageMessage && (msg.message.imageMessage.caption ?? "").trim() === ".sticker";      const hasVideoWithStickerCaption =        !!msg.message.videoMessage && (msg.message.videoMessage.caption ?? "").trim() === ".sticker";      const isStickerCommand = text === ".sticker" || text === ".s";      const quotedImage = isStickerCommand ? getQuotedImageMessage(msg) : null;      const quotedVideo = isStickerCommand ? getQuotedVideoMessage(msg) : null;      if (hasImageWithStickerCaption || quotedImage || hasVideoWithStickerCaption || quotedVideo) {        try {          if (hasVideoWithStickerCaption || quotedVideo) {            const videoMsg = hasVideoWithStickerCaption              ? (msg.message.videoMessage as proto.IVideoMessage)              : (quotedVideo as proto.IVideoMessage);            const stream = await downloadContentFromMessage(videoMsg, "video");            const buf = await streamToBuffer(stream);            const stickerBuf = await makeStickerFromVideoBuffer(buf);            await sock.sendMessage(remoteJid, { sticker: stickerBuf });            return;          }          const imageMsg = hasImageWithStickerCaption            ? (msg.message.imageMessage as proto.IImageMessage)            : (quotedImage as proto.IImageMessage);          const stream = await downloadContentFromMessage(imageMsg, "image");          const imgBuf = await streamToBuffer(stream);          const stickerBuf = await makeStickerFromImageBuffer(imgBuf);          await sock.sendMessage(remoteJid, { sticker: stickerBuf });        } catch {          await sock.sendMessage(remoteJid, { text: "Gagal bikin sticker." });        }        return;      }      if (text === ".toimg") {        const quotedSticker = getQuotedStickerMessage(msg);        if (!quotedSticker) {          await sock.sendMessage(remoteJid, { text: "Reply sticker lalu ketik .toimg" });          return;        }        try {          const stream = await downloadContentFromMessage(quotedSticker, "sticker");          const webpBuf = await streamToBuffer(stream);          const png = await stickerWebpToPng(webpBuf);          await sock.sendMessage(remoteJid, { image: png });        } catch {          await sock.sendMessage(remoteJid, { text: "Gagal convert sticker ke gambar." });        }        return;      }      if (!isGroup) return;      const meta = await getGroupMeta(sock, remoteJid);      const admin = isSenderAdmin(meta, senderJid);      const owner = isOwnerJid(senderJid);      const botJid = sock.user?.id ? (sock.user.id.includes("@") ? sock.user.id : `${sock.user.id}@s.whatsapp.net`) : "";      const botIsAdmin = botJid ? isBotAdminInGroup(meta, botJid) : false;      const g = getGroupSettings(remoteJid);      if (text === ".admin") {        const admins = meta.participants.filter((p: any) => p.admin === "admin" || p.admin === "superadmin");        if (admins.length === 0) {          await sock.sendMessage(remoteJid, { text: "Tidak ada admin terdeteksi." });          return;        }        const lines = admins.map((p: any, i: number) => `${i + 1}. @${getMentionNumber(p.id)}${p.admin === "superadmin" ? " (superadmin)" : ""}`);        await sock.sendMessage(remoteJid, { text: ` Admin Grup:\n${lines.join("\n")}`, mentions: admins.map((p: any) => p.id) });        return;      }      if (g.muted && !admin && !owner) {        if (text.startsWith(".mute")) {          if (!admin && !owner) return;        } else if (text.startsWith(".welcome") || text.startsWith(".setwelcome") || text.startsWith(".antilink") || text.startsWith(".tagall") || text.startsWith(".setppgc") || text.startsWith(".kick") || text.startsWith(".add") || text.startsWith(".filter") || text.startsWith(".hidetag") || text.startsWith(".addrespon") || text.startsWith(".delrespon") || text.startsWith(".listrespon")) {          return;        } else {          if (text.startsWith(".")) return;          const groupMap = getGroupResponses(remoteJid);          const keyExact = text.toLowerCase().trim();          const replyExact = groupMap[keyExact];          if (replyExact) return;          const filters = g.filters || {};          const lower = text.toLowerCase();          const keys = Object.keys(filters);          for (const k of keys) {            if (k && lower.includes(k.toLowerCase())) return;          }          return;        }      }      if (text.startsWith(".mute")) {        if (!admin && !owner) {          await sock.sendMessage(remoteJid, { text: " Command ini hanya untuk admin grup." });          return;        }        const arg = text.replace(".mute", "").trim().toLowerCase();        if (arg !== "on" && arg !== "off") {          await sock.sendMessage(remoteJid, { text: "Pakai: .mute on / .mute off" });          return;        }        g.muted = arg === "on";        await saveSettings();        await sock.sendMessage(remoteJid, { text: ` Mute ${g.muted ? "ON" : "OFF"} di grup ini.` });        return;      }      if (text.startsWith(".welcome")) {        if (!admin && !owner) {          await sock.sendMessage(remoteJid, { text: " Command ini hanya untuk admin grup." });          return;        }        const arg = text.replace(".welcome", "").trim().toLowerCase();        if (arg !== "on" && arg !== "off") {          await sock.sendMessage(remoteJid, { text: "Pakai: .welcome on / .welcome off" });          return;        }        g.welcomeOn = arg === "on";        await saveSettings();        await sock.sendMessage(remoteJid, { text: ` Welcome ${g.welcomeOn ? "ON" : "OFF"} di grup ini.` });        return;      }      if (text.startsWith(".setwelcome")) {        if (!admin && !owner) {          await sock.sendMessage(remoteJid, { text: " Command ini hanya untuk admin grup." });          return;        }        const payload = text.replace(/^\.setwelcome\b/i, "").trim();        if (!payload) {          await sock.sendMessage(remoteJid, { text: "Contoh: .setwelcome Welcome ya!\nBisa pakai \\n untuk baris baru" });          return;        }        g.welcomeText = payload.replace(/\\n/g, "\n").slice(0, 4000);        await saveSettings();        await sock.sendMessage(remoteJid, { text: " Welcome text diupdate." });        return;      }      if (text.startsWith(".tagall")) {        if (!admin && !owner) {          await sock.sendMessage(remoteJid, { text: " Command ini hanya untuk admin grup." });          return;        }        const content = text.replace(".tagall", "").trim();        const members = meta.participants.map((p: any) => p.id);        const mentionText = members.map((jid: string) => `@${getMentionNumber(jid)}`).join(" ");        const finalText = (content ? content + "\n\n" : "") + mentionText;        await sock.sendMessage(remoteJid, { text: finalText.slice(0, 4000), mentions: members });        return;      }      if (text.startsWith(".setppgc")) {        if (!admin && !owner) {          await sock.sendMessage(remoteJid, { text: " Command ini hanya untuk admin grup." });          return;        }        if (!botIsAdmin) {          await sock.sendMessage(remoteJid, { text: " Bot harus admin biar bisa ganti foto grup." });          return;        }        const imageMsg = msg.message.imageMessage ? (msg.message.imageMessage as proto.IImageMessage) : getQuotedImageMessage(msg);        if (!imageMsg) {          await sock.sendMessage(remoteJid, { text: "Kirim foto dengan caption .setppgc atau reply foto lalu .setppgc" });          return;        }        try {          const stream = await downloadContentFromMessage(imageMsg, "image");          const imgBuf = await streamToBuffer(stream);          await sock.updateProfilePicture(remoteJid, imgBuf);          await sock.sendMessage(remoteJid, { text: " Foto grup diganti." });        } catch {          await sock.sendMessage(remoteJid, { text: " Gagal ganti foto grup." });        }        return;      }      if (text.startsWith(".kick")) {        if (!admin && !owner) {          await sock.sendMessage(remoteJid, { text: " Command ini hanya untuk admin grup." });          return;        }        if (!botIsAdmin) {          await sock.sendMessage(remoteJid, { text: " Bot harus admin biar bisa kick." });          return;        }        let targets: string[] = [];        const mentionTargets = getMentionedJids(msg);        if (mentionTargets.length) targets = mentionTargets;        const quotedJid = msg.message?.extendedTextMessage?.contextInfo?.participant as string | undefined;        if (targets.length === 0 && quotedJid) targets = [quotedJid];        targets = targets.filter((j) => j.endsWith("@s.whatsapp.net"));        if (targets.length === 0) {          await sock.sendMessage(remoteJid, { text: "Tag orangnya atau reply chat orangnya lalu .kick" });          return;        }        try {          await sock.groupParticipantsUpdate(remoteJid, targets, "remove");          await sock.sendMessage(remoteJid, { text: ` Kick: ${targets.map((j) => `@${getMentionNumber(j)}`).join(" ")}`, mentions: targets });        } catch {          await sock.sendMessage(remoteJid, { text: " Gagal kick." });        }        return;      }      if (text.startsWith(".add")) {        if (!admin && !owner) {          await sock.sendMessage(remoteJid, { text: " Command ini hanya untuk admin grup." });          return;        }        if (!botIsAdmin) {          await sock.sendMessage(remoteJid, { text: " Bot harus admin biar bisa add." });          return;        }        const payload = text.replace(/^\.add\b/i, "").trim();        if (!payload) {          await sock.sendMessage(remoteJid, { text: "Contoh: .add 62812xxxx" });          return;        }        const numbers = payload.split(/[,\s]+/).map((s) => s.trim()).filter(Boolean);        const jids = numbers.map((n) => toUserJidFromPhone(n));        try {          await sock.groupParticipantsUpdate(remoteJid, jids, "add");          await sock.sendMessage(remoteJid, { text: ` Add request: ${jids.map((j) => `@${getMentionNumber(j)}`).join(" ")}`, mentions: jids });        } catch {          await sock.sendMessage(remoteJid, { text: " Gagal add." });        }        return;      }      if (text.startsWith(".antilink whitelist")) {        if (!admin && !owner) {          await sock.sendMessage(remoteJid, { text: " Command ini hanya untuk admin grup." });          return;        }        const rest = text.replace(/^\.antilink\s+whitelist\b/i, "").trim();        const [sub, ...tail] = rest.split(/\s+/);        const cmd = (sub || "").toLowerCase();        if (cmd === "add") {          const dom = normalizeDomain(tail.join(" "));          if (!dom) {            await sock.sendMessage(remoteJid, { text: "Contoh: .antilink whitelist add chat.whatsapp.com" });            return;          }          const list = g.whitelistDomains || [];          if (!list.includes(dom)) list.push(dom);          g.whitelistDomains = list;          await saveSettings();          await sock.sendMessage(remoteJid, { text: ` Whitelist ditambah: ${dom}` });          return;        }        if (cmd === "del") {          const dom = normalizeDomain(tail.join(" "));          if (!dom) {            await sock.sendMessage(remoteJid, { text: "Contoh: .antilink whitelist del chat.whatsapp.com" });            return;          }          const list = (g.whitelistDomains || []).filter((d) => d !== dom);          g.whitelistDomains = list;          await saveSettings();          await sock.sendMessage(remoteJid, { text: ` Whitelist dihapus: ${dom}` });          return;        }        if (cmd === "list") {          const list = g.whitelistDomains || [];          if (list.length === 0) {            await sock.sendMessage(remoteJid, { text: "Whitelist kosong." });            return;          }          await sock.sendMessage(remoteJid, { text: ` Whitelist:\n${list.map((d, i) => `${i + 1}. ${d}`).join("\n")}` });          return;        }        await sock.sendMessage(remoteJid, {          text: "Pakai:\n.antilink whitelist add <domain>\n.antilink whitelist del <domain>\n.antilink whitelist list",        });        return;      }      if (text.startsWith(".filter")) {        if (!admin && !owner) {          await sock.sendMessage(remoteJid, { text: " Command ini hanya untuk admin grup." });          return;        }        const rest = text.replace(/^\.filter\b/i, "").trim();        const [sub, ...tail] = rest.split(/\s+/);        const cmd = (sub || "").toLowerCase();        if (cmd === "add") {          const payload = tail.join(" ").trim();          const sepIndex = payload.indexOf("|");          if (sepIndex === -1) {            await sock.sendMessage(remoteJid, { text: "Format: .filter add kata|jawaban" });            return;          }          const key = payload.slice(0, sepIndex).trim().toLowerCase();          const val = payload.slice(sepIndex + 1).trim();          if (!key || !val) {            await sock.sendMessage(remoteJid, { text: "Format: .filter add kata|jawaban" });            return;          }          if (!g.filters) g.filters = {};          g.filters[key] = val;          await saveSettings();          await sock.sendMessage(remoteJid, { text: ` Filter ditambah: "${key}"` });          return;        }        if (cmd === "del") {          const key = tail.join(" ").trim().toLowerCase();          if (!key) {            await sock.sendMessage(remoteJid, { text: "Format: .filter del kata" });            return;          }          if (!g.filters || !g.filters[key]) {            await sock.sendMessage(remoteJid, { text: " Kata itu belum ada." });            return;          }          delete g.filters[key];          await saveSettings();          await sock.sendMessage(remoteJid, { text: ` Filter dihapus: "${key}"` });          return;        }        if (cmd === "list") {          const map = g.filters || {};          const keys = Object.keys(map);          if (keys.length === 0) {            await sock.sendMessage(remoteJid, { text: " Belum ada filter." });            return;          }          const list = keys            .sort()            .slice(0, 80)            .map((k, i) => `${i + 1}. ${k}`)            .join("\n");          await sock.sendMessage(remoteJid, { text: ` *Daftar Filter:*\n${list}` });          return;        }        await sock.sendMessage(remoteJid, { text: "Pakai:\n.filter add kata|jawaban\n.filter del kata\n.filter list" });        return;      }      if (text.startsWith(".hidetag")) {        if (!admin && !owner) {          await sock.sendMessage(remoteJid, { text: " Command ini hanya untuk admin grup." });          return;        }        const content = text.replace(".hidetag", "").trim();        if (!content) {          await sock.sendMessage(remoteJid, { text: " Contoh: .hidetag Halo" });          return;        }        const allMembers = meta.participants.map((p: any) => p.id);        await sock.sendMessage(remoteJid, { text: content, mentions: allMembers });        return;      }      if (text.startsWith(".antilink")) {        if (!admin && !owner) {          await sock.sendMessage(remoteJid, { text: " Command ini hanya untuk admin grup." });          return;        }        const arg = text.replace(".antilink", "").trim().toLowerCase();        if (arg !== "on" && arg !== "off") {          if (!text.toLowerCase().includes("whitelist")) {            await sock.sendMessage(remoteJid, { text: " Pakai: .antilink on / .antilink off" });          }          return;        }        setAntiLink(remoteJid, arg === "on");        await sock.sendMessage(remoteJid, {          text: ` AntiLink ${arg === "on" ? "AKTIF" : "NONAKTIF"} di grup ini.\n Bot harus admin supaya bisa hapus pesan member.`,        });        return;      }      if (text.startsWith(".addrespon")) {        if (!admin && !owner) {          await sock.sendMessage(remoteJid, { text: " Command ini hanya untuk admin grup." });          return;        }        const payload = text.replace(".addrespon", "").trim();        const sepIndex = payload.indexOf("|");        if (sepIndex === -1) {          await sock.sendMessage(remoteJid, { text: " Format: .addrespon kata|jawaban" });          return;        }        const key = payload.slice(0, sepIndex).trim();        const val = payload.slice(sepIndex + 1).trim();        if (!key || !val) {          await sock.sendMessage(remoteJid, { text: " Format: .addrespon kata|jawaban" });          return;        }        const groupMap = getGroupResponses(remoteJid);        groupMap[key.toLowerCase()] = val;        await saveResponses();        await sock.sendMessage(remoteJid, { text: ` Respon ditambah: "${key}"` });        return;      }      if (text.startsWith(".delrespon")) {        if (!admin && !owner) {          await sock.sendMessage(remoteJid, { text: " Command ini hanya untuk admin grup." });          return;        }        const key = text.replace(".delrespon", "").trim().toLowerCase();        if (!key) {          await sock.sendMessage(remoteJid, { text: " Format: .delrespon kata" });          return;        }        const groupMap = getGroupResponses(remoteJid);        if (!groupMap[key]) {          await sock.sendMessage(remoteJid, { text: " Kata itu belum ada." });          return;        }        delete groupMap[key];        await saveResponses();        await sock.sendMessage(remoteJid, { text: ` Respon dihapus: "${key}"` });        return;      }      if (text === ".listrespon") {        if (!admin && !owner) {          await sock.sendMessage(remoteJid, { text: " Command ini hanya untuk admin grup." });          return;        }        const groupMap = getGroupResponses(remoteJid);        const keys = Object.keys(groupMap);        if (keys.length === 0) {          await sock.sendMessage(remoteJid, { text: " Belum ada respon tersimpan." });          return;        }        const list = keys          .sort()          .slice(0, 80)          .map((k, i) => `${i + 1}. ${k}`)          .join("\n");        await sock.sendMessage(remoteJid, { text: ` *Daftar Respon:*\n${list}` });        return;      }      if (!text.startsWith(".")) {        const groupMap = getGroupResponses(remoteJid);        const keyExact = text.toLowerCase().trim();        const replyExact = groupMap[keyExact];        if (replyExact) {          await sock.sendMessage(remoteJid, { text: replyExact });          return;        }        const filters = g.filters || {};        const lower = text.toLowerCase();        const keys = Object.keys(filters);        for (const k of keys) {          if (k && lower.includes(k.toLowerCase())) {            await sock.sendMessage(remoteJid, { text: filters[k] });            return;          }        }      }      if (!isAntiLinkOn(remoteJid)) return;      if (admin || owner) return;      const found = extractLinks(text);      if (found.length === 0) return;      const hasNonWhite = found.some((u) => !(isWhitelisted(u) || isWhitelistedForGroup(remoteJid, u)));      if (!hasNonWhite) return;      try {        if (botIsAdmin) {          await sock.sendMessage(remoteJid, { delete: msg.key });        }        await sock.sendMessage(remoteJid, {          text: ` Link tidak diizinkan di grup ini.`,          mentions: senderJid ? [senderJid] : [],        });      } catch {}    } catch {}  });}start().catch(console.error);